<script>
document.addEventListener("DOMContentLoaded", function () {
  const letterInput = document.getElementById("letterInput");
  const changeLetterButton = document.getElementById("changeLetterButton");
  const categoryInput = document.getElementById("categoryInput");
  const resultsContainer = document.getElementById("resultsContainer");

  let typingTimer; // Timer for detecting typing pauses
  let isTypingWord = false; // Track if a word is being typed

  // Helper function to alphabetize the data
  function alphabetizeData(data) {
    const sortedData = {};
    Object.keys(data)
      .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' })) // Sort letters case-insensitively
      .forEach((letter) => {
        sortedData[letter] = {};
        Object.keys(data[letter])
          .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' })) // Sort categories case-insensitively
          .forEach((category) => {
            sortedData[letter][category] = data[letter][category];
          });
      });
    return sortedData;
  }

  const sortedData = alphabetizeData(data); // Ensure the data is always sorted

  function displayResults(letter, categoryFilter = "") {
    resultsContainer.innerHTML = ""; // Clear previous results
    const filteredData = {};

    // If no category filter is applied, display all categories for the letter
    if (sortedData[letter]) {
      Object.keys(sortedData[letter])
        .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' })) // Ensure categories are sorted alphabetically
        .forEach((category) => {
          if (
            !categoryFilter ||
            category.toLowerCase().includes(categoryFilter.toLowerCase())
          ) {
            filteredData[category] = sortedData[letter][category];
          }
        });
    }

    const sortedCategories = Object.keys(filteredData); // Already sorted
    if (sortedCategories.length === 0) {
      resultsContainer.innerHTML = "<p>No results found.</p>";
      return;
    }

    const controlsHeight = document.querySelector(".controls").offsetHeight;
    const viewportHeight = window.innerHeight;
    const availableHeight = viewportHeight - controlsHeight; // Total height available for rows
    const rowHeight = 15; // Fixed row height
    const totalRows = Math.floor(2 * availableHeight / rowHeight); // Adjusted total rows calculation
    const rowsPerGrid = Math.ceil(totalRows / 4); // Divide rows evenly across 4 grids

    // Create grids and populate them
    let gridCount = 0;
    let lastLetter = ""; // Track the last letter used

    while (gridCount * rowsPerGrid < sortedCategories.length && gridCount < 4) {
      const gridDiv = document.createElement("div");
      gridDiv.className = "results";
      gridDiv.style.justifyContent = "flex-start"; // Ensure items are top-aligned within each grid

      sortedCategories
        .slice(gridCount * rowsPerGrid, (gridCount + 1) * rowsPerGrid)
        .forEach((category) => {
          const currentLetter = category[0].toUpperCase();
          const letterDiv = document.createElement("div");
          letterDiv.className = "letter";

          // Show the letter only for the first category of the group
          if (currentLetter !== lastLetter) {
            letterDiv.textContent = currentLetter;
            letterDiv.style.backgroundColor = "#ddd";
          } else {
            letterDiv.textContent = " ";
            letterDiv.style.backgroundColor = "transparent";
          }

          gridDiv.appendChild(letterDiv);
          lastLetter = currentLetter;

          const categoryCell = document.createElement("div");
          categoryCell.className = "category";
          categoryCell.textContent = category;
          gridDiv.appendChild(categoryCell);

          const answerCell = document.createElement("div");
          answerCell.className = "answer";
          answerCell.textContent = filteredData[category][0] || "N/A";
          gridDiv.appendChild(answerCell);
        });

      resultsContainer.appendChild(gridDiv);
      gridCount++;
    }

    // Apply fixed row height dynamically
    document.querySelectorAll(".letter, .category, .answer").forEach((el) => {
      el.style.height = `${rowHeight}px`;
    });
  }

  // Handle typing and input behavior
  categoryInput.addEventListener("input", (event) => {
    clearTimeout(typingTimer);
    const letter = letterInput.value.toUpperCase();
    const value = categoryInput.value.trim();

    if (value.length === 1 && !isTypingWord) {
      // Single letter typed, switch to a new letter
      letterInput.value = value.toUpperCase(); // Update letter input
      categoryInput.value = ""; // Reset category input
      displayResults(value.toUpperCase());
    } else {
      // Treat as a word if there is no pause
      isTypingWord = true;
      displayResults(letter, value); // Filter results by category
    }

    // Set timer to detect pause
    typingTimer = setTimeout(() => {
      isTypingWord = false; // Reset to letter switching mode
    }, 500);
  });

  letterInput.addEventListener("input", () => {
    const letter = letterInput.value.toUpperCase();
    if (letter) {
      displayResults(letter); // Display results for the selected letter
      letterInput.style.display = "none"; // Hide the letter input
      changeLetterButton.style.display = "inline-block"; // Show the "Change Letter" button
      categoryInput.style.display = "inline-block"; // Show category input
      categoryInput.focus(); // Automatically focus on the search category input
    }
  });

  changeLetterButton.addEventListener("click", () => {
    letterInput.value = "";
    categoryInput.value = "";
    resultsContainer.innerHTML = "";
    letterInput.style.display = "inline-block"; // Show the letter input
    changeLetterButton.style.display = "none"; // Hide the "Change Letter" button
    categoryInput.style.display = "none"; // Hide category input
    letterInput.focus();
  });

  // Adjust container height dynamically
  function adjustResultsHeight() {
    const controlsHeight = document.querySelector(".controls").offsetHeight;
    const viewportHeight = window.innerHeight;
    resultsContainer.style.height = `${viewportHeight - controlsHeight}px`;
  }

  window.addEventListener("resize", adjustResultsHeight);
  adjustResultsHeight();
});
</script>
